
bfs 与 dfs 使用内置数据，展示深度优先与广度优先的便利方法
其中build_data 用来获取数据，
bfs 与 dfs 方法用来展示效果

数据结构：
'''
data
            A
    B       C       D
E   F       G       H   I

J           K       L
M           N
            O

'''

结果
['a', 'b', 'e', 'j', 'm', 'f', 'c', 'g', 'k', 'n', 'o', 'd', 'h', 'l', 'i']
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o']

Dijkstra.py 是用来展示Dijkstra算法效果的文件。
为了实际展示最短路径的效果，
使用了统一的专利数据集，利用专利的引用与被引用数据作为专利之间的连接点。
node 方法，定义了节点情况
load_data 方法 ： 从数据中获取树桩node数据
Dijkstra 方法： 在定义了起始点与树状图之后，获取最短路径

{'CN105847820B': 0, 'CN1551633A': 1, 'CN1905675A': 1, 'US2011/0170612A1': 1, 'CN101646084A': 1, 'CN104185990B': 99999, 'CN102186075A': 99999, 'CN102238387A': 99999, 'US2009034611A1': 99999, 'CN103460284B': 99999, 'CN101483043A': 99999, 'CN101388210A': 99999, 'US2002/0111799A1': 99999, 'US2003/0078771A1': 99999}
其中 0 为其实点， 1为最短路径经过点， 99999 为其余节点

Centrality.py 通过degree 与 close 两种平法方法衡量最短路径节点的重要程度也
结果：
degree_cen =  [3, 1, 1, 1, 2, 0]
close_cen =  [0.02666666666666667, 0.024, 0.01818181818181818, 0.1, 0.04, 0]